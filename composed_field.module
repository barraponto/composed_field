<?php
/**
 * @file
 * Defines composed field type.
 */

/**
 * Implements hook_field_info().
 */
function composed_field_field_info() {
  return array(
    // We name our field as the associative name of the array.
    'composed_field' => array(
      'label' => t('Composed field'),
      'description' => t('This field stores serialized array in the database.'),
      'default_widget' => 'composed_field_widget',
      'default_formatter' => 'composed_field_formatter',
    ),
  );
}

/**
 * Implements hook_field_widget_info().
 */
function composed_field_field_widget_info() {
  return array(
    'composed_field_widget' => array(
      'label' => t('Composed field'),
      'field types' => array('composed_field'),
      // 'settings' => array('rows' => 5),
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function composed_field_field_formatter_info() {
  return array(
    // This formatter just displays the hex value in the color indicated.
    'composed_field_formatter' => array(
      'label' => t('Composed field'),
      'field types' => array('composed_field'),
    ),
  );
}

/**
 * Implements hook_field_is_empty().
 *
 * hook_field_is_emtpy() is where Drupal asks us if this field is empty.
 * Return TRUE if it does not contain data, FALSE if it does. This lets
 * the form API flag an error when required fields are empty.
 */
function composed_field_field_is_empty($item, $field) {
  //return empty($item['rgb']);
  
  // TODO:
  return FALSE;
  
}

/**
 * Implements hook_field_widget_settings_form().
 */
function composed_field_field_widget_settings_form($field, $instance) {
  // Array of previously saved setting values, unless this field is being
  // created.
  $default_values = $instance['widget']['settings'];
  $number_of_subfields_title = t('Number of subfields');

  $default_values['number_of_subfields'] = 3;

  if (empty($default_values['number_of_subfields'])) {
    $default_values['number_of_subfields'] = '';
    $number_of_subfields = 1;
    // State of the Widget Form elements.
    $disabled = TRUE;
    $default_value = t('You must enter a value into !number_of_subfields', array('!number_of_subfields' => $number_of_subfields_title));
  }
  else {
    $number_of_subfields = $default_values['number_of_subfields'];
    // State of the Widget Form elements.
    $disabled = FALSE;
    $default_value = '';
  }

  // Check if $instance['widget']['settings']['composed_field'] is set.
  $default_values_for_type_are_set = FALSE;
  if (isset($default_values['composed_field']['_#type'])) {
    $default_values_for_type_are_set = TRUE;
  }

  $form['inline'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display as inline element'),
    '#default_value' => (empty($default_values['inline'])) ? FALSE : $default_values['inline'],
  );

  // This element determines how many components our field will have.
  $form['number_of_subfields'] = array(
    '#type' => 'textfield',
    '#title' => $number_of_subfields_title,
    '#description' => t('Enter a numeric value and hit the tab key after that.') . '<br />' .
      t('This value determines how many subfields this field will have.'),
    '#default_value' => $default_values['number_of_subfields'],
    '#maxlength' => 2,
    '#size' => 2,
    '#element_validate' => array('element_validate_integer_positive'),
    '#required' => TRUE,
    '#ajax' => array(
      'callback' => '_composed_field_number_of_fields_ajax_callback',
    ),
  );

  $form['composed_field'] = array(
    '#type' => 'vertical_tabs',
  );

  $form_controls = _composed_field_form_controls_api();

  foreach($form_controls as $form_control => $form_control_values) {
    // The Form API wont allow form element names starting with #, so we add a _
    // before the form control attribute name.
    $form_control_attribute = "_$form_control";

    // Set a vertical tab for each form control attribute.
    $form['composed_field'][$form_control_attribute] = array(
      '#title' => $form_control,
      '#type' => 'fieldset',
      '#description' => t('See !form_controls for more details.',
        array('!form_controls' => l(t('Form Controls'),
        'http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7',
        array('attributes' => array('target' => '_blank'))))
      ),
    );


    // Build the widget form in each tab.
    for ($subfield = 1;
         $subfield <= $number_of_subfields;
         $subfield++) {

      foreach($form_control_values['widget_form'] as $form_element => $form_element_properties) {

        $form_element_properties['#disabled'] = $disabled;

        if ($form_control == '#type') {
          if ($disabled) {
            // The user hasn't entered a value into Number of subfields as yet.
            $form_element_properties['#options'] = array('' => $default_value);
          }
        }
        else {
          // Some form control attributes are not required depending on the
          // form control type selected on each subfield.
          $form['composed_field'][$form_control_attribute][$subfield]['enabled'] = array(
            '#type' => 'checkbox',
            '#title' => t('Enable !attribute attribute for Subfield !subfield.', array('!attribute' => $form_control, '!subfield' => $subfield)),
            '#disabled' => $disabled,
            '#ajax' => array(
              'callback' => '_composed_field_enabled_ajax_callback',
            ),
          );
        }

        // Get default value from $instance['widget']['settings'].
        $form_element_properties['#default_value'] = $default_value;
        if ($default_values_for_type_are_set) {
          $form_element_properties['#default_value'] = $default_value = $default_values['composed_field'][$form_control_attribute][$subfield][$form_element];
        }

        // Check if this is the element that holds the form control property
        // value.
        if ($form_element == 'value') {
          // Set title.
          $title = (empty($form_element_properties['#title'])) ? '' : $form_element_properties['#title'];
          $form_element_properties['#title'] = $title . t('Subfield !subfield', array('!subfield' => $subfield));
        }
        $form['composed_field'][$form_control_attribute][$subfield][$form_element] = $form_element_properties;


      }
    }
  }

    //'#default_value' => list_allowed_values_string(empty($settings[$subfield]['select']['allowed_values']) ? array() : $settings[$subfield]['select']['allowed_values']),

  return $form;
}



/**
 * AJAX callback.
 *
 * @internal
 *   Form: hook_field_widget_settings_form().
 *   Form element: number_of_fields.
 */
function _composed_field_number_of_fields_ajax_callback($form, $form_state) {
    
}

/**
 * AJAX callback.
 *
 * @internal
 *   Form: hook_field_widget_settings_form().
 *   Form element: _#type.
 */
function _composed_field_type_ajax_callback($form, $form_state) {
  $submmited_values = $form_state['values']['instance']['widget']['settings'];
  //$triggering_element = $form_state['triggering_element'];
  
  // The reason for using the array key 5 is because of this:
  // [0] => instance
  // [1] => widget
  // [2] => settings
  // [3] => composed_field
  // [4] => _#type
  // [5] => < THE SUBFIELD NUMBER >
  // [6] => value.
  //$subfield_number = $triggering_element['#parents'][5];
  //$subfields_total = $submmited_values['number_of_subfields'];

  $default_values_for_type_are_set = _composed_field_default_values_for_type_are_set($submmited_values['composed_field']['_#type']);

  // We only want any action to be taken after all values in the #type tab
  // are filled up.  
  if ($default_values_for_type_are_set) {

    $file = "/tmp/test.txt";
    // Open the file to get existing content
    // $current = file_get_contents($file);
    // Append a new person to the file
    $current = print_r($submmited_values, TRUE);
    // Write the contents back to the file
    file_put_contents($file, $current);

  }
  else{
    return;
  }
}

/**
 * Check if all values in the #type tab have been fullfilled.
 *
 * @param Array $type_submitted_values
 *   The submitted values of the #type tab form.
 *
 * @return Boolean
 *   Whether or not there is still any subfield value for #type left to be
 *   selected.
 */
function _composed_field_default_values_for_type_are_set($type_submitted_values) {
  $default_values_for_type_are_set = TRUE;

  foreach($type_submitted_values as $subfield => $form_values) {
    if (isset($form_values['value']) &&
        empty($form_values['value'])) {
      $default_values_for_type_are_set = FALSE;
      // Having at least one subfield value for #type yet to be selected is
      // enough to set FALSE for $default_values_for_type_are_set so we stop
      // the looping.
      break;
    }
  }

  return $default_values_for_type_are_set;
}


/**
 * AJAX callback.
 *
 * @internal
 *   Form: hook_field_widget_settings_form().
 *   Form element: enabled.
 */
function _composed_field_enabled_ajax_callback($form, $form_state) {
    
}

/**
 * Implements hook_field_widget_form().
 */
function composed_field_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  
  
  
  
  return $element;  
}


/**
 * Form Control Attributes.
 *
 * @see http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7
 *
 * @return Array
 *   Map of the form controls api.
 */
function _composed_field_form_controls_api() {
  include_once('includes/composed_field.form.controls.inc');
  return $form_controls;
}

